# 팀 리더 회고 — 에이전트 팀 운영 경험

> Loop Server Sprint 1~2를 에이전트 팀으로 진행하면서 리더 역할에서 겪은 어려움과 교훈 정리.

---

## 1. 모델 제약과 팀 구성 조정

**상황**: 사용자가 코더에게 `opusplan` 모델(plan mode 전용 Opus)을 쓰게 하려 했으나, Task 도구의 model 파라미터는 `sonnet`, `opus`, `haiku`만 지원. `opusplan`은 사용 불가였다.

**어려움**: 사용자의 의도(코더가 plan mode에서 Opus 사고력으로 계획 → 코드 작성)를 도구 제약 내에서 실현해야 했다. 결국 planner(opus, Plan 타입)와 coder(sonnet, general-purpose)로 분리하는 구조로 타협.

**교훈**: 에이전트 도구의 모델/타입 제약을 팀 설계 전에 정확히 파악하고, 사용자에게 먼저 보고해야 한다. 안 되는 걸 되는 것처럼 진행하면 나중에 더 큰 조정 비용이 든다.

---

## 2. 병렬 작업 시 공유 파일 소유권 충돌

**상황**: Sprint 2에서 category-coder와 task-coder를 동시 스폰. 양쪽 모두 `CategoriesTable.kt`와 `TasksTable.kt`(common/)이 필요했다.

**어려움**:
- category-coder에게 양쪽 테이블 생성을 맡기고 task-coder에게는 "없으면 기다려라"고 했지만, task-coder가 Infrastructure 단계에 도달했을 때 파일이 아직 없어서 직접 생성해버렸다.
- category-coder는 나중에 "이미 존재한다"고 보고. 누가 만든 버전이 최종인지 불명확.
- 결과적으로 빌드는 통과했지만, 운이 좋았을 뿐 구조적으로 해결된 것은 아니었다.

**교훈**: 공유 파일은 코더 스폰 전에 리더가 직접 생성하거나, worktree 격리 후 머지하는 전략이 필요하다. "나중에 만들어질 거야"라는 암묵적 의존은 병렬 환경에서 동작하지 않는다.

---

## 3. 허브-앤-스포크 통신의 병목

**상황**: 사용자 지시로 팀원 간 직접 소통을 금지. 모든 정보가 리더를 경유.

**어려움**:
- Planner의 계획 결과를 리더가 읽고, 사용자에게 보고하고, 결정을 받고, 다시 Coder에게 전달하는 3단계 릴레이. 한 사이클에 상당한 컨텍스트 전달 비용 발생.
- Sprint 1 coder 피드백을 Sprint 2 coder에게 전달할 때, 리더가 모든 피드백을 수집·정리·재구성해야 했다.
- 리뷰어의 지적사항을 fix-coder에게 전달할 때도 동일한 변환 작업 필요.

**교훈**: 허브-앤-스포크는 품질 통제에 유리하지만, 리더의 컨텍스트 윈도우와 처리 능력이 병목이 된다. 특정 상황(예: 리뷰어 → fix-coder)에서는 제한적 직접 통신을 허용하는 것이 효율적일 수 있다.

---

## 4. 코더 프롬프트의 완전성 확보

**상황**: 각 코더에게 기존 코드 패턴, 설계 결정, 파일 구조, 주의사항을 포함한 종합 프롬프트를 제공.

**어려움**:
- 아무리 상세하게 작성해도 누락이 발생. `deleteWhere` import, `Column<Long>` vs `Column<EntityID<Long>>` 구분, `andWhere` vs `and` 사용법 등.
- 코더가 직접 codebase를 읽으면 해결되는 문제지만, 읽는 시간 = 비용. 프롬프트에 미리 담으면 그 비용을 줄일 수 있다.
- 리팩토링 코더에게는 위반 파일 목록을 제공했지만 `UpdateCategoryService`가 누락되어 빌드 실패 후에야 발견. grep 전수 조사 결과를 넘겼어야 했다.

**교훈**: 코더 프롬프트 작성 시 "내가 코더라면 이 프롬프트만으로 바로 구현할 수 있는가?"를 자문해야 한다. 특히 Exposed ORM처럼 메이저 버전 변경이 있는 라이브러리는 import 경로, API 변경점을 구체적으로 나열해야 한다.

---

## 5. Idle 상태의 팀원 관리

**상황**: 팀원이 메시지를 보낸 후 자동으로 idle 상태로 전환. 후속 지시를 보내도 즉시 반응하지 않는 경우 존재.

**어려움**:
- 문서화 요청을 보냈지만 idle 알림만 반복되어 재요청 필요. 메시지가 전달되었는지, 처리 중인지, 무시된 것인지 판단 어려움.
- "idle = 대기 중"이지만, 간혹 메시지를 수신했음에도 반응하지 않는 케이스가 있어 2~3회 재전송 필요.

**교훈**: 중요한 지시는 작업 완료 보고 수신 직후(idle 전환 전)에 바로 전달하는 것이 가장 확실하다. 별도 메시지로 분리하면 idle 사이클에 빠질 수 있다.

---

## 6. 리뷰 결과의 아키텍처 결정 부담

**상황**: 보안 리뷰에서 CreateTaskService의 카테고리 소유권 미검증(IDOR) 발견. 아키텍처 리뷰에서도 동일 지적 + "BC 격리 규칙 때문에 CategoryRepository를 Task BC에서 쓸 수 없다"는 제약 추가.

**어려움**:
- 단순 코드 수정이 아니라 아키텍처 설계 결정이 필요한 이슈. 리더가 코드를 작성하지 않는 역할이므로, 결정만 하고 구현은 코더에게 위임해야 하는데, 결정 자체가 코드 수준의 이해를 요구.
- 해결 방안이 3가지(TaskRepository에 메서드 추가 / common 공유 인터페이스 / Application Service 레벨 해결) 있었고, 각각 트레이드오프가 달라서 사용자 판단을 구해야 했다.

**교훈**: 리뷰어에게 "문제 지적 + 추천 해결방안 1가지"를 함께 요청하는 것이 효율적. 선택지만 나열하면 리더가 아키텍처 결정을 떠안게 된다.

---

## 7. 팀원 수명 주기 관리

**상황**: 사용자가 "정리하라고 할 때까지 정리하지 마"라고 명시.

**어려움**:
- 작업이 끝난 planner, coder가 계속 대기 상태로 존재. 리소스 낭비이지만 사용자 지시 없이 종료할 수 없음.
- 반대로 리뷰어 스폰 타이밍에서 "기존 리뷰어 정리 → 새 리뷰어 스폰"을 사용자가 지시했을 때, 종료 확인을 기다리는 동안 시간 소요.
- Sprint 2 시작 시 "coders 정리해", "planners도 정리해", "리뷰어도 정리해"가 각각 별도 지시로 와서 3번에 걸쳐 정리.

**교훈**: 팀원 수명 주기 정책을 프로젝트 시작 시 명확히 합의하는 것이 좋다. 예: "스프린트 단위로 자동 정리" 또는 "역할 완료 즉시 정리" 등.

---

## 8. 컨텍스트 윈도우 압박

**상황**: Sprint 1 전체(Foundation + Member + Auth) → 리뷰 → 수정 → Sprint 2(Category + Task) → 리뷰 → 리팩토링을 하나의 대화에서 진행.

**어려움**:
- 대화 후반부에서 초반 결정사항이나 코드 패턴을 참조해야 할 때 컨텍스트가 이미 압축된 상태. 파일을 다시 읽어야 하는 비용 발생.
- 팀원에게 보낸 프롬프트 내용을 기억해야 하는데, 팀원 수 × 프롬프트 크기가 상당.

**교훈**: 장기 프로젝트에서는 핵심 결정사항을 별도 파일(예: `docs/decisions.md`)에 누적 기록하여, 컨텍스트 압축 이후에도 참조 가능하게 해야 한다.

---

## 9. "리더가 코드를 안 짜는" 규칙의 현실적 한계

**상황**: 리더는 조율만, 코드 작성은 코더만.

**어려움**:
- 공유 파일(CategoriesTable, TasksTable) 사전 생성이 필요한 상황에서 리더가 직접 만들면 병렬 작업 충돌을 방지할 수 있었지만, 규칙상 불가.
- 리팩토링 프롬프트 작성 시 "이렇게 수정해라"를 코드 수준으로 상세히 기술해야 했는데, 이 자체가 사실상 코드 작성과 다를 바 없는 인지 부하.
- 간단한 1줄 수정(예: GlobalExceptionHandler에 핸들러 추가)도 코더를 스폰해야 하는 오버헤드.

**교훈**: "리더가 코드를 안 짠다"는 규칙은 대규모 팀에서 의미가 있지만, 소규모 에이전트 팀에서는 "인프라/설정 수준의 사소한 변경은 리더가 직접 처리"하는 예외를 두는 것이 효율적일 수 있다.

---

## 10. 팀 규모 — 과했는가?

**실제 스폰 수**: 총 16명 (Sprint 1: 9명, Sprint 2: 7명)

| 역할 | 실제 인원 | 평가 |
|------|----------|------|
| Planner | 5명 (BC당 1명) | **과다** |
| Coder | 5명 (BC당 1명) | 적정~약간 과다 |
| Reviewer | 4명 (스프린트당 2명) | 적정 |
| Fix/Refactor | 2명 | 적정 |

**Planner가 과했던 이유:**
- Plan 타입은 파일 작성이 안 돼서, 리더가 계획서를 대신 저장해야 했음. Planner의 출력을 리더가 복사-붙여넣기하는 작업이 반복.
- 각 Planner가 한 BC 계획만 세우고 바로 idle → 대기만 하다가 종료. 실질 가동률이 극히 낮음.
- **스프린트당 Planner 1명**이 순차적으로 전 BC 계획을 수립해도 속도 차이가 크지 않았을 것. 병렬화의 이점보다 조율 비용이 더 컸음.

**Coder도 통합 가능했던 부분:**
- Foundation은 설정/마이그레이션 위주라 규모가 작아서, Member와 같은 코더가 순차 처리해도 됐음.
- Category + Task는 공유 파일(CategoriesTable, TasksTable) 충돌 문제를 감안하면 1명이 순차 처리하는 게 오히려 빠를 수 있었음. 실제로 병렬 스폰했더니 타이밍 이슈로 task-coder가 빌드 실패를 보고.

**Reviewer는 적정:**
- arch(opus) + security(sonnet) 분리는 관점이 달라서 의미 있었음.
- 스프린트당 새로 스폰하는 것도 맞았음 — 이전 코드 컨텍스트 없이 순수하게 새 코드만 리뷰.

**이상적인 구성 (다시 한다면):**

| 역할 | 인원 | 비고 |
|------|------|------|
| Planner | 스프린트당 1명 | 전 BC 계획을 순차 수립 |
| Coder | 스프린트당 1~2명 | 의존성 없는 BC만 병렬, 나머지 순차 |
| Reviewer | 스프린트당 2명 | arch + security 유지 |
| Fix | 필요시 1명 | 리뷰 후 수정용 |

**Sprint 1: 4~5명, Sprint 2: 4~5명 → 총 8~10명**이면 충분. 실제 16명 대비 약 40% 절감이고, 조율 비용은 절반 이하로 줄었을 것.

**핵심 교훈**: 에이전트 팀에서 "인원 = 병렬성 = 속도"가 아니다. 공유 자원이 있으면 병렬화의 이점이 조율 비용에 의해 상쇄된다. 병렬 스폰은 완전히 독립적인 작업에만 적용해야 한다.

---

## 요약: 다음 프로젝트에 반영할 개선사항

| # | 개선사항 | 기대 효과 |
|---|---------|----------|
| 1 | 공유 파일은 코더 스폰 전에 사전 생성 | 병렬 작업 충돌 방지 |
| 2 | 코더 프롬프트에 grep 전수 조사 결과 포함 | 누락 방지 |
| 3 | 리뷰어에게 "추천 해결방안 1가지" 함께 요청 | 리더 결정 부담 감소 |
| 4 | 핵심 결정을 `docs/decisions.md`에 누적 기록 | 컨텍스트 압축 후에도 참조 가능 |
| 5 | 팀원 수명 주기 정책 사전 합의 | 정리 타이밍 혼선 방지 |
| 6 | 중요 지시는 완료 보고 직후 즉시 전달 | idle 사이클 회피 |
| 7 | 사소한 인프라 변경은 리더 직접 처리 허용 | 스폰 오버헤드 감소 |
| 8 | Exposed ORM 등 주요 라이브러리 import 목록을 별도 가이드 문서화 | 코더 삽질 시간 감소 |
| 9 | Planner는 스프린트당 1명으로 통합 | 스폰/조율 비용 절감 |
| 10 | 병렬 코더는 완전 독립 작업일 때만 적용 | 공유 파일 충돌 방지 |
